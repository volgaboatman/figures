# 3 способа написать Hello World на NET.Core

## Краткое описание задачи

Напишите приложение для работы с геометрическими фигурами, предоставляющее следующий API:

- метод /figure, который принимает POST-запрос с параметрами фигуры (предусмотреть круг и треугольник) и сохраняет ее в персистентное хранилище (по умолчанию SQLite, если хотите использовать другое решение, то необходимо предоставить Docker-контейнер с приложением и выбранной СУБД). Сервис должен возвращать идентификатор фигуры

- метод /figure/{id}, который по GET-запросу с идентификатором фигуры возвращает ее площадь, если фигура содержится в БД.

## Disclaimer

На данный момент это не Production Ready решения, а скорее тема для обсуждения. В каждом варианте есть свои недоделки (например, в варианте Simple не хватает обработки ошибок), нигде нет нормального логгирования, каталоги и проекты именованы не идеально и в реальном проекте скорее всего их нужно будет разделить на части (например, отделить описания команд и реализацию в разные проекты), по-хорошему надо настроить маппинги через AutoMapper (или вообще попробовать использовать record для DTO объектов) и т.д.

В каждом варианте db-слой вырожденный и тупо сохраняет объекты в виде json в поле Data. В варинте CQRS вообще нет сохранения исходного состояния объекта, есть сохранение только площади (дело было вечром очень спать хотелось). Но так как есть установка на простоту - то для демонстрации нормально. Возможно, в будущем надо будет показать, как можно слой хранения данных изменять и сколько переделок для этого понадобится (опять-таки в варианте CQRS надо сделать 2 хранилища - исходны данных и рассчитанной площади)

Тесты есть на основные сложные случаи, но далеко не полные.

## Примеры запросов

Примеры запросов и тестовые сценарии см. в коллеции Figure.postman_collection.json в каталоге postman

### Запуск коллекции

- Запустить один из проектов на http://localhost:5000

- В каталоге postman сделать `npm install`

- Запустить `run-local.cmd`

Для linux соотв. переделать команды.

### Краткое описание запросов

- POST http://localhost:5000/figure, в теле запроса надо передать одну из приведенных фигур:

Запрос:

```json
{
  "Circle": {
    "Radius": 100
  },
  "Triangle": {
    "A": 40,
    "B": 40,
    "Angle": 90
  }
}
```

Ответ:

```json
{
  "Id": "GUID"
}
```

- GET http://localhost:5000/figure/{guid}

Ответ:

```json
{
  "Area": "Double"
}
```

## Вариант Simple

Вариант, который обычно делают начинающие разработчики. Прям в контроллере открываем сессию к БД и пишем/читаем объекты на лету немного их преобразовывая. Логика расчета площади живет вместе с DTO. В реальной жизны так делать не рекомнедуется, так как сложно тестировать и при разрастании функциональности все превращается в неподдерживаемый лапшекод. Но в очень экстремальных случаях, например надо лопатить очень большие объемы или надо написать что-то простое очень быстро и есть обещание что это все прототип и мы потом переделаем (<b>ВНИМАНИЕ</b>: Не верьте таким обещаниям, как правило никто никогда не будет переделывать) можно использовать.

## Вариант clean-arch

По мотивам Clean Architecture (не 100% верная реализация, возможны не верные названия и для чистоты не хватает еще пары классов). Демонстрирует случай, когда мы делаем слой бизнес-логики, не зависимый ни от каких других частей программы и можно заменять как интерфейсную часть (может мы неожиданно решим делать не REST интерфейс, а GRPC) так и часть хранения (например, у нас какая-то сторонняя система и там структура меняется вне зависимости от нас). В реализации нет async чтобы интерфейсы выглядели более читабельными (и вообще похожими на Java), в реальной жизны естественно надо будет делать async запросы в базу.

## Вариант CQRS

Демонстрирует реализацию через шаблон CQRS с использованием библиотеки MediatR. Логика расчета площади выполняется соотв. командой и соотв. логика чтения становится тривиальной. Такой вариант организации логики очень хорошо подходит если планируется масштабирование системы так как команды/запросы можно будет выполнять через очереди (Rabbit и прочие) на разных микросервисах (например, можно сделать отдельный микросервис для каждого типа фигур и отдельный для аналитический запросов получения площади и т.д.).

### TODO

- Для полноты демонстрации необходимо сделать отдельную базу для хранения исходных объектов, сейчас ее вообще нет что противоречит заданию.

- Логика маршрутизации команд таки осталась в контроллере, что не очень правильно, по хорошему надо сделать для маршрутизации отдельную команду.

## Идеальный вариант

Идеального варианта не существует. По опыту чаще всего всего используется некоторая комбинация из clean-arch и CQRS, но у каждого варианта есть как плюсы, так и минусы. Плюс к тому в реальной жизни есть еще очень много внешних факторов таких как планируемый жизненный цикл проекта, умения команды и т.д.
